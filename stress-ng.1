.\"                                      Hey, EMACS: -*- nroff -*-
.\" First parameter, NAME, should be all caps
.\" Second parameter, SECTION, should be 1-8, maybe w/ subsection
.\" other parameters are allowed: see man(7), man(1)
.TH STRESS-NG 1 "November 1, 2014"
.\" Please adjust this date whenever revising the manpage.
.\"
.\" Some roff macros, for reference:
.\" .nh        disable hyphenation
.\" .hy        enable hyphenation
.\" .ad l      left justify
.\" .ad b      justify to both left and right margins
.\" .nf        disable filling
.\" .fi        enable filling
.\" .br        insert line break
.\" .sp <n>    insert n+1 empty lines
.\" for manpage-specific macros, see man(7)
.SH NAME
stress\-ng \- a tool to load and stress a computer system.
.br

.SH SYNOPSIS
.B stress\-ng
[\fIOPTION \fR[\fIARG\fR]] ...
.br

.SH DESCRIPTION
stress\-ng will stress test a computer system in various selectable ways. It
was designed to exercise various physical subsystems of a computer as well
as the various operating system kernel interfaces.
stress-ng also has a wide range of CPU specific stress tests that exercise floating point, integer, bit manipulation and control flow.
.PP
stress-ng was originally intended to make a machine work hard and trip
hardware issues such as thermal overruns as well as operating
system bugs that only occur when a system is being thrashed hard. Use stress-ng
with caution as some of the tests can make a system run hot
on poorly designed hardware and also can cause excessive system thrashing
which may be difficult to stop.
.PP
stress-ng can also measure test throughput rates; this can be
useful to observe performace changes across different
operating system releases or types of hardware. However, it has never been
intended to be used as a precise benchmark test suite, so do NOT use it
in this manner.
.PP
Running stress-ng with root privileges will adjust out of memory settings
on Linux systems to make the stressors unkillable in low memory situations,
so use this judiciously.  With the appropriate privilege, stress-ng can allow
the ionice class and ionice levels to be adjusted, again, this should be
used with care.
.PP
One can specify the number of processes to invoke per type of stress test; specifying
a negative or zero value will select the number of online processors as defined
by sysconf(_SC_NPROCESSORS_ONLN).
.SH OPTIONS
.TP
.B \-?, \-h, \-\-help
show help.
.TP
.B \-\-affinity N
start N processes that rapidly change CPU affinity (only on Linux). Rapidly switching
CPU affinity can contribute to poor cache behaviour.
.TP
.B \-\-affinity-ops N
stop affinity processes after N bogo affinity operations (only on Linux).
.TP
.B \-a N, \-\-all N
start N instances of each stress test.
.TP
.B \-b N, \-\-backoff N
wait N microseconds between the start of each stress process. This allows one
to ramp up the stress tests over time.
.TP
.B \-B N, \-\-bigheap N
start N processes that grow their heaps by reallocating memory. If the out of memory
killer (OOM) on Linux kills the process or the allocation fails then the allocating process starts all
over again.  Note that the OOM adjustment for the process is set so that the OOM killer
will treat these processes as the first candidate processes to kill.
.TP
.B \-\-bigheap\-ops N
stop the big heap processes after N bogo allocation operations are completed.
.TP
.B \-\-bigheap\-growth N
specify amount of memory to grow heap by per iteration. Size can be from 4K to 64MB. Default is 64K.
.TP
.B \-C N, \-\-cache N
start N processes that perform random wide spread memory read and writes to thrash the CPU cache.  The code does not intelligently determine the CPU cache configuration and so it may be sub-optimal in producing hit-miss read/write activity for some processors.
.TP
.B \-\-cache\-ops N
stop cache thrash processes after N bogo cache thrash operations.
.TP
.B \-\-clock N
start N processes exercising clocks and POSIX timers. For all known clock types this will exercise clock_getres(), clock_gettime() and clock_nanosleep(). For
all known timers it will create a 50000ns timer and busy poll this until it expires.  This stressor will cause frequent context switching.
.TP
.B \-\-clock-ops N
stop clock stress processes after N bogo operations.
.TP
.B \-c N, \-\-cpu N
start N processes computing by default sqrt(rand()). Note that the rand function
is based on a fast integer RNG with a period of about 2^60. One can specify different
CPU stress methods with the \-\-cpu\-method option.
.TP
.B \-\-cpu\-ops N
stop cpu stress processes after N bogo operations.
.TP
.B \-l P, \-\-cpu\-load P
load CPU with P percent loading. 0 is effectivly a sleep (no load) and 100 is full loading.  The loading loop is broken into compute time (load%) and sleep time (100% - load%). Accuracy depends on the overall load of the processor and the responsiveness of the scheduler, so the actual load may be different from the desired load.  Note that the number of bogo CPU operations may not be linearly scaled with the load as some systems employ CPU frequency scaling and so heavier loads produce an increased CPU frequency and greater CPU bogo operations.
.TP
.B \-\-cpu\-method method
specify cpu stress method. By default, sqrt(rand()) is used, however, there are a selection of ways the CPU can be stressed:
.TS
l l.
\fBMethod	Description\fR
all	iterate over all the below cpu stress methods
ackermann	T{
Ackermann function: compute A(3, 10), where:
 A(m, n) = n + 1 if m = 0;
 A(m - 1, 1) if m > 0 and n = 0;
 A(m - 1, A(m, n - 1)) if m > 0 and n > 0
T}
bitops	T{
various bit operations from bithack, namely: reverse bits, parity check, bit count, round to nearest power of 2
T}
correlate	T{
perform a 16384 \(mu 1024 correlation of random doubles
T}
crc	T{
compute 1024 rounds of CCITT CRC16 on random data
T}
double	mix of double precision floating point operations
euler	compute e using n \[eq] (1 + (1 \[di] n)) \[ua] n
explog	iterate on n \[eq] exp(log(n) \[di] 1.00002)
fibonacci	T{
compute Fibonacci sequence of 0, 1, 1, 2, 5, 8...
T}
fft	4096 sample Fast Fourier Transform
float	mix of floating point operations
gcd	compute GCD of integers
gray	T{
calculate binary to gray code and gray code back to binary for integers
from 0 to 65535
T}
hamming	T{
compute Hamming H(8,4) codes on 262144 lots of 4 bit data. This turns 4 bit data into 8 bit Hamming code containing 4 parity bits. For data bits d1..d4, parity bits are computed as:
  p1 = d2 + d3 + d4
  p2 = d1 + d3 + d4
  p3 = d1 + d2 + d4
  p4 = d1 + d2 + d3
T}
hanoi	T{
solve a 21 disc Towers of Hanoi stack using the recursive solution
T}
hyperbolic	compute hyperbolic sinh\(*h \(mu cosh\(*h
idct	8 \(mu 8 IDCT (Inverse Discrete Cosine Transform)
int8	mix of 8 bit integer operations
int16	mix of 16 bit integer operations
int32	mix of 32 bit integer operations
int64	mix of 64 bit integer operations
jenkin	T{
Jenkin's integer hash on 128 rounds of 128..1 bytes of random data
T}
jmp	Simple unoptimised compare >, <, == and jmp branching
ln2	T{
compute ln(2) based on series:
 1 - 1/2 + 1/3 - 1/4 + 1/5 - 1/6 ...
T}
longdouble	T{
mix of long double precision floating point operations
T}
loop	simple empty loop
matrixprod	T{
matrix product of two 128 \(mu 128 matrices of double floats. Testing on 64 bit x86 hardware shows that this is provides a good mix of memory, cache and floating point operations and is probably the best CPU method to use to make a CPU run hot.
T}
nsqrt	sqrt() using Newtonâ€“Raphson
omega	T{
compute the omega constant defined by \(*We\[ua]\(*W = 1 using efficient iteration of \(*Wn+1 = (1 + \(*Wn) / (1 + e\[ua]\(*Wn)
T}
phi	compute the Golden Ratio \(*f using series
pi	T{
compute \(*p using the Srinivasa Ramanujan fast convergence algorithm
T}
pjw	T{
128 rounds of hash pjw function on 128 to 1 bytes of random strings
T}
prime	T{
find all the primes in the range  1..1000000 using a slightly
optimised brute force naive trial division search
T}
psi	T{
compute \(*q (the reciprocal Fibonacci constant) using the sum of the
reciprocals of the Fibonacci numbers
T}
rand	T{
16384 iterations of rand(), where rand is the MWC pseudo
random number generator.
The MWC random function concatenates two 16 bit multiply\-with\-carry generators:
 x(n) = 36969 \(mu x(n - 1) + carry,
 y(n) = 18000 \(mu y(n - 1) + carry mod 2 \[ua] 16
.br
and has period of around 2 \[ua] 60
T}
rgb	convert RGB to YUV and back to RGB (CCIR 601)
sieve	T{
find the primes in the range 1..10000000 using the sieve of Eratosthenes
T}
sqrt	sqrt(rand())
trig	sin\(*h \(mu cos\(*h
zeta	T{
compute the Riemann Zeta function \[*z](s) for s = 2.0..10.0
T}
.TE
.RS
.PP
Note that some of these methods try to exercise the CPU with
computations found in some real world use cases. However, the
code has not been optimised on a per-architecture basis, so
may be a sub-optimal compared to hand-optimised code used
in some applications.  They do, however, try to represent
the typical instruction mixes found in these use cases.
.RE
.TP
.B \-D N, \-\-dentry N
start N processes that create and remove directory entries.  This should create file system meta data activity.
.TP
.B \-\-dentry\-ops N
stop denty thrash processes after N bogo dentry operations.
.TP
.B \-\-dentries N
create N dentries per dentry thrashing loop, default is 2048.
.TP
.B \-\-dir N
start N processes that create and remove directories using mkdir and rmdir.
.TP
.B \-\-dir\-ops N
stop directory thrash processes after N bogo directory operations.
.TP
.B \-n, \-\-dry-run
parse options, but don't run stress tests. A no-op.
.TP
.B \-\-eventfd N
start N parent and child worker processes that read and write 8 byte event messages between them via the eventfd mechanism (Linux only).
.TP
.B \-\-eventfd-ops N
stop eventfd workers after N bogo operations.
.TP
.B \-F N, \-\-fallocate N
start N processes continally fallocating (preallocating file space) and ftuncating (file truncating) temporary files.
.TP
.B \-\-fallocate\-ops N
stop fallocate stress processes after N bogo fallocate operations.
.TP
.B \-f N, \-\-fork N
start N processes continually forking children that immediately exit.
.TP
.B \-\-flock N
start N processes locking on a single file.
.TP
.B \-\-flock-ops N
stop flock stress processes after N bogo flock operations.
.TP
.B \-\-fork\-ops N
stop fork stress processes after N bogo operations.
.TP
.B \-\-fork\-max P
create P processes and then wait for them to exit per iteration. The default is just 1; higher
values will create many temporary zombie processes that are waiting to be reaped. One can
potentially fill up the the process table using high values for \-\-fork\-max and \-\-fork.
.TP
.B \-\-fstat N
start N processes fstat'ing files in a directory (default is /dev).
.TP
.B \-\-fstat\-ops N
stop fstat stress process after N bogo fstat operations.
.TP
.B \-\-fstat\-dir directory
specify the directory to fstat to override the default of /dev.
All the files in the directory will be fstat'd repeatedly.
.TP
.B \-\-futex N
start N stressors that rapidly exercise the futex system call. Each stressor has two processes, a futex waiter and a futex waker. The waiter waits with a very small timeout to stress the timeout and rapid polled futex waiting. This is a Linux specific stress option.
.TP
.B \-\-futex-ops N
stop futex stressors after N bogo successful futex wait operations.
.TP
.B \-\-get N
start N stressors that call all the get*() system calls.
.TP
.B \-\-get-ops N
stop get stressors after N bogo get operations.
.TP
.B \-d N, \-\-hdd N
start N processes continually writing and removing temporary files.
.TP
.B \-\-hdd\-bytes N
write N bytes for each hdd process, the default is 1 GB.
.TP
.B \-\-hdd\-noclean
do not remove files created by hdd processes.
.TP
.B \-\-hdd\-ops N
stop hdd stress processes after N bogo operations.
.TP
.B \-\-hdd\-write\-size N
specify size of each write in bytes. Size can be from 1 byte to 4MB.
.TP
.B \-\-inotify N
start N processes performing file system activities such as making/deleting files/directories, moving files, etc. to stress exercise the various inotify events (Linux only).
.TP
.B \-\-inotify-ops N
stop inotify stress processes after N inotify bogo operarions.
.TP
.B \-i N, \-\-io N
start N processes continuously calling sync() to commit buffer cache to disk. This can be used in conjunction with the \-\-hdd options.
.TP
.B \-\-io\-ops N
stop io stress processes after N bogo operations.
.TP
.B \-\-ionice-class class
specify ionice class (only on Linux). Can be idle (default), besteffort, be, realtime, rt.
.TP
.B \-\-ionice-level level
specify ionice level (only on Linux). For idle, 0 is the only possible option. For besteffort or realtime values 0 (hightest priority) to 7 (lowest priority). See ionice(1) for more details.
.TP
.B \-k, \-\-keep\-name
by default, stress-ng will attempt to change the name of the stress processes according to their functionality; this option disables this and keeps the process names to be the name of the parent process, that is, stress-ng.
.TP
.B \-\-kill N
start N processes sending SIGUSR1 kill signals to a SIG_IGN signal handler. Most of the process time will end up in kernel space.
.TP
.B \-\-kill\-ops N
stop kill processes after N bogo kill operations.
.TP
.B \-\-link N
start N processes creating and removing hardlinks.
.TP
.B \-\-link-ops N
stop link stress processes after N bogo operations.
.TP
.B \-\-metrics
output number of bogo operations in total performed by the stress processes. Note that these are not a reliable metric of performance or throughput and have not
been designed to be used for benchmarking whatsoever. The metrics are just a useful way to observe how a system behaves when under various kinds of load.
.RS
.PP
The metrics show the total cumulative CPU time consumed by all the processors exercised by a stress process. For example, if a test is run for 10 seconds across 8 processors, the total CPU time will be 80 seconds.
.RE
.TP
.B -\-metrics\-brief
enable metrics and only output metrics that are non-zero.
.TP
.B \-\-mmap N
start N processes continuously calling mmap()/munmap().  The initial mapping is a large chunk (size specified by \-\-mmap\-bytes) followed by pseudo-random 4K unmappings, then pseudo-random 4K mappings, and then linear 4K unmappings. Note that this can cause systems to trip the kernel OOM killer on Linux systems if not enough physical memory and swap is not available.  The
MAP_POPULATE option is used to populate pages into memory on systems that support this.
.TP
.B \-\-mmap\-ops N
stop mmap stress processes after N bogo operations.
.TP
.B \-\-mmap\-bytes N
allocate N bytes per mmap stress process, the default is 256MB. One can specify the size in units of Bytes,
KBytes, MBytes and GBytes using the suffix b, k, m or g.
.TP
.B \-\-msg N
start N sender and receiver processes that continually send and receive messages using System V message IPC.
.TP
.B \-\-msg-ops N
stop after N bogo message send operations completed.
.TP
.B \-\-nice N
start N cpu consuming processes that exercise the available nice levels. Each iteration forks off a child process that runs through the all the nice levels running a busy loop for 0.1 seconds per level and then exits.
.TP
.B \-\-nice-ops N
stop after N nice bogo nice loops
.TP
.B \-\-null N
start N processes writing to /dev/null.
.TP
.B \-\-null\-ops N
stop null stress processes after N /dev/null bogo write operations.
.TP
.B \-o N, \-\-open N
start N processes that perform open() and then close() operations on /dev/zero. The maximum opens at one time is system defined, so the test will run up to this maximum, or 65536 open file descriptors, which ever comes first.
.TP
.B \-\-open-ops N
stop the open stress processes after N bogo open operations.
.TP
.B \-p N, \-\-pipe N
start N stressors that perform large pipe writes and reads to exercise pipe I/O. This exercises memory write and reads as well as context switching.  Each stressor has two processes, a reader and a writer.
.TP
.B \-\-pipe\-ops N
stop pipe stress processes after N bogo pipe write operations.
.TP
.B \-P N, \-\-poll N
start N processes that perform zero timeout polling via the poll(), select() and sleep() system calls. This wastes system and user time doing nothing.
.TP
.B \-\-poll\-ops N
stop poll stress processes after N bogo poll operations.
.TP
.B \-\-procfs N
start N processes that read files from /proc and recursively read files from /proc/self (Linux only).
.TP
.B \-\-procfs-ops N
stop procfs reading after N bogo read operations. Note, since the number of entries may vary between kernels, this bogo ops metric is probably very misleading.
.TP
.B \-Q, \-\-qsort N
start N processes that sort 32 bit integers using qsort.
.TP
.B \-\-qsort\-ops N
stop qsort srtess processes after N bogo qsorts.
.TP
.B \-\-qsort\-size N
specify number of 32 bit integers to sort, default is 262144 (256 \(mu 1024).
.TP
.B \-q, \-\-quiet
don't show any output.
.TP
.B \-r N, \-\-random N
start N random stress processes.
.TP
.B \-\-rdrand N
start N processes that read the Intel hardware random number generator (Intel Ivybridge processors upwards).
.TP
.B \-\-rdrand-ops N
stop rdrand stress processes after N bogo rdrand operations (1 bogo op = 2048 random bits successfully read).
.TP
.B \-R N, \-\-rename N
start N processes that each create a file and then repeatedly rename it.
.TP
.B \-\-rename\-ops N
stop rename stress processes after N bogo rename operations.
.TP
.B \-\-sched scheduler
select the named scheduler (only on Linux). To see the list of available schedulers
use: stress\-ng \-\-sched which
.TP
.B \-\-sched\-prio prio
select the scheduler priority level (only on Linux). If the scheduler does not support this then
the default priority level of 0 is chosen.
.TP
.B \-\-sem N
start N processes that perform POSIX semaphore wait and post operation. This stresses fast semaphore operations and produces rapid context switching.
.TP
.B \-\-sem-ops N
stop semaphore stress processes after N bogo semaphore operations.
.TP
.B \-\-sendfile N
start N processes that send an empty file to /dev/null. This operation spends nearly all the time in the kernel.  The default sendfile size is 4MB.  The sendfile options are for Linux only.
.TP
.B \-\-sendfile\-ops N
stop sendfile stressors after N sendfile bogo operations.
.TP
.B \-\-sendfile\-size S
specify the size to be copied with each sendfile call. The default is 4MB.  Since the data is copied from a temporary file of the same size in /tmp, large values for this option may cause excessive swapping if /tmp is a memory based filesystem. One can specify the size in units of Bytes, KBytes, MBytes and GBytes using the suffix b, k, m or g.
.TP
.B \-\-sequential N
sequentially run all the stressors one by one for a default of 60 seconds. The
number of each individual stressors to be started is N.  If N is zero, then a
stressor for each processor that is on-line is executed. Use the \-\-timeout
option to specify the duration to run each stressor.
.TP
.B \-\-sigfpe N
start N processes that rapidly cause division by zero SIGFPE faults.
.TP
.B \-\-sigfpe-ops N
stop sigfpe stress processes after N bogo SIGFPE faults.
.TP
.B \-\-sigsegv N
start N processes that rapidly create and catch segmentation faults.
.TP
.B \-\-sigsegv-ops N
stop sigsegv stress processes after N bogo segmentation faults.
.TP
.B \-\-sigq N
start N processes that rapidly send SIGUSR1 signals using sigqueue() to child processes that wait for the signal via sigwaitinfo().
.TP
.B \-\-sigq-ops N
stop sigq stress processes after N bogo signal send operations.
.TP
.B \-S N, \-\-sock N
start N stressors that perform various socket stress activity. This involves a pair of client/server processes performing rapid connect, send and receives and disconnects on the local host.
.TP
.B \-\-sock-port P
start at socket port P. For N socket worker processes, ports P to P - 1 are used.
.TP
.B \-\-sock-ops N
stop socket stress processes after N bogo operations.
.TP
.B \-s N, \-\-switch N
start N processes that send messages via pipe to a child to force context switching.
.TP
.B \-\-switch\-ops N
stop context switcing processes after N bogo operations.
.TP
.B \-\-symlink N
start N processes creating and removing symbolic links.
.TP
.B \-\-symlink-ops N
stop symlink stress processes after N bogo operations.
.TP
.B \-\-sysinfo N
start N processes that continually read system and process specific information.  This reads the process user and system times using the times(2) system call. For Linux systems, it also reads overall system statistics using the sysinfo(2) system call and also the file system statistics for all mounted file systems using statfs(2).
.TP
.B \-\-sysinfo\-ops N
stop the sysinfo stressors after N bogo operations.
.TP
.B \-t N, \-\-timeout N
stop stress test after N seconds. One can also specify the units of time in
seconds, minutes, hours, days or years with the suffix s, m, h, d or y.
.TP
.B \-T N, \-\-timer N
start N processes creating timer events at a default rate of 1Mhz (Linux only); this
can create a lot of timer clock interrupts.
.TP
.B \-\-timer-ops N
stop timer stress processes after N bogo timer events (Linux only).
.TP
.B \-\-timer-freq F
run timers at F Hz; range from 1000 to 1000000000 Hz (Linux only). By selecting an
appropriate frequency stress-ng can generate hundreds of thousands of interrupts per
second.
.TP
.B \-u N, \-\-urandom N
start N processes reading /dev/urandom (Linux only). This will load the kernel random number source.
.TP
.B \-\-urandom\-ops N
stop urandom stress processes after N urandom bogo read operations (Linux only).
.TP
.B \-\-utime N
start N processes updating file timestamps. This is mainly CPU bound when the default is used as the system flushes metadata changes only periodically.
.TP
.B \-\-utime-ops N
stop utime stress processes after N utime bogo operations.
.TP
.B \-\-utime-fsync
force metadata changes on each file timestamp update to be flushed to disk. This forces the test to become I/O bound and will result in many dirty metadata writes.
.TP
.B \-v, \-\-verbose
show all debug, warnings and normal information output.
.TP
.B \-\-verify
verify results when a test is run. This is not available on all tests. This will sanity check the
computations or memory contents from a test run and report to stderr any unexpected failures.
.TP
.B \-V, \-\-version
show version.
.TP
.B \-m N, \-\-vm N
start N processes continuously calling mmap()/munmap() and writing to the allocated memory. Note that this can cause systems to trip the kernel OOM killer on Linux systems if not enough physical memory and swap is not available.
.TP
.B \-\-vm\-bytes N
mmap N bytes per vm process, the default is 256MB. One can specify the size in units of Bytes,
KBytes, MBytes and GBytes using the suffix b, k, m or g.
.TP
.B \-\-vm\-stride N
write to every Nth byte, the default is every page (4096 bytes). One can specify the size in
units of Bytes, KBytes, MBytes and GBytes using the suffix b, k, m or g.
.TP
.B \-\-vm\-ops N
stop vm stress processes after N bogo operations.
.TP
.B \-\-vm\-hang N
sleep N seconds before unmapping memory, the default is zero seconds. Specifying 0 will
do an infinite wait.
.TP
.B \-\-vm\-keep
don't continually unmap and map memory, just keep on re-writing to it.
.TP
.B \-\-vm\-locked
Lock the pages of the mapped region into memory using mmap MAP_LOCKED (since Linux 2.5.37).  This is similar to locking memory as described in mlock(2).
.TP
.B \-\-vm\-populate
populate (prefault) page tables for the memory mappings; this can stress swapping. Only available on systems that support MAP_POPULATE (since Linux 2.5.46).
.TP
.B \-y N, \-\-yield N
start N process that call sched_yield(). This should force rapid context switching.
.TP
.B \-\-yield\-ops N
stop yield stress processes after N sched_yield() bogo operations.
.TP
.B \-\-zero N
start N processes reading /dev/zero.
.TP
.B \-\-zero\-ops N
stop zero stress processes after N /dev/zero bogo read operations.
.LP
.SH EXAMPLES
.LP
stress\-ng \-\-cpu 4 \-\-io 2 \-\-vm 1 \-\-vm\-bytes 1G \-\-timeout 60s
.IP
runs for 60 seconds with 4 cpu stressors, 2 io stressors and 1 vm stressor using 1GB of virtual memory.
.LP
stress\-ng \-\-cpu 8 \-\-cpu\-ops 800000
.IP
runs 8 cpu stressors and stops after 800000 bogo operations.
.LP
stress\-ng \-\-sequential 2 \-\-timeout 2m \-\-metrics
.IP
run 2 simultaneous instances of all the stressors sequentially one by one, each for 2 minutes and summaries with performance metrics at the end.
.LP
stress\-ng \-\-cpu 4 \-\-cpu-method fft \-\-cpu-ops 10000 \-\-metrics\-brief
.IP
run 4 FFT cpu stressors, stop after 10000 bogo operations and produce a summary just for the FFT results.
.LP
stress\-ng \-\-cpu 0 \-\-cpu-method all \-t 1h
.IP
run cpu stressors on all online CPUs working through all the available CPU stressors for 1 hour.
.LP
stress\-ng \-\-all 4 \-\-timeout 5m
.IP
run 4 instances of all the stressors for 5 minutes.
.LP
stress\-ng \-\-random 64
.IP
run 64 stressors that are randomly chosen from all the available stressors.
.LP
stress\-ng \-\-cpu 64 \-\-cpu\-method all \-\-verify \-t 10m \-\-metrics\-brief
.IP
run 64 instances of all the different cpu stressors and verify that the
computations are correct for 10 minutes with a bogo operations summary at the
end.
.LP
stress\-ng --sequential 0 -t 10m
.IP
run all the stressors one by one for 10 minutes, with the number of instances
of each stressor matching the number of online CPUs.
.SH BUGS
File bug reports at:
  https://launchpad.net/ubuntu/+source/stress-ng/+filebug
.SH SEE ALSO
.BR fallocate (2),
.BR flock (2),
.BR ftruncate (2),
.BR ionice (1),
.BR ioprio_set (2),
.BR qsort (3),
.BR sched_yield (2),
.BR sched_setaffinity (2),
.BR stress (1)
.SH AUTHOR
stress\-ng was written by Colin King <colin.king@canonical.com> and
is a clean room re-implementation of the original
stress tool by Amos Waterland <apw@rossby.metr.ou.edu>.
.SH NOTES
Note that the stress-ng cpu, io, vm and hdd tests are different
implementations of the original stress
tests and hence may produce different stress characteristics.
stress-ng does not support any GPU stress tests.
.PP
The bogo operations metrics may change with each release  because of bug
fixes to the code, new features, compiler optimisations or changes in system call performance.
.PP
This manual page was written by Colin King <colin.king@canonical.com>,
for the Ubuntu project (but may be used by others).
